"""PRD to JSON Converter Workflow for MAT.

This module provides a workflow that converts PRD markdown files to JSON format
suitable for Ralph's autonomous build loop.
"""

import json
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from utils.file_ops import read_file, write_file
from utils.logger import get_logger, log_agent_action


@dataclass
class StoryData:
    """A user story in JSON format.

    Attributes:
        id: Unique story identifier (e.g., US-001).
        title: Short story title.
        description: User story description.
        acceptance_criteria: List of acceptance criteria.
        priority: Story priority/order.
        passes: Whether the story has been implemented successfully.
        notes: Additional notes (typically empty initially).
    """

    id: str
    title: str
    description: str
    acceptance_criteria: list[str] = field(default_factory=list)
    priority: int = 0
    passes: bool = False
    notes: str = ""

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary format for JSON serialization.

        Returns:
            Dictionary with camelCase keys for JSON output.
        """
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "acceptanceCriteria": self.acceptance_criteria,
            "priority": self.priority,
            "passes": self.passes,
            "notes": self.notes,
        }


@dataclass
class PRDJson:
    """PRD in JSON format for Ralph.

    Attributes:
        project: Project name.
        branch_name: Git branch for Ralph (ralph/project-name).
        description: Project description.
        user_stories: List of user stories.
    """

    project: str = ""
    branch_name: str = ""
    description: str = ""
    user_stories: list[StoryData] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary format for JSON serialization.

        Returns:
            Dictionary representation of the PRD.
        """
        return {
            "project": self.project,
            "branchName": self.branch_name,
            "description": self.description,
            "userStories": [s.to_dict() for s in self.user_stories],
        }

    def to_json(self, indent: int = 2) -> str:
        """Convert to JSON string.

        Args:
            indent: JSON indentation level.

        Returns:
            Formatted JSON string.
        """
        return json.dumps(self.to_dict(), indent=indent)


def _normalize_branch_name(project_name: str) -> str:
    """Convert project name to kebab-case branch name.

    Args:
        project_name: Project name (may contain spaces, capitals).

    Returns:
        Kebab-case branch name prefixed with 'ralph/'.
    """
    # Convert to lowercase and replace spaces/underscores with hyphens
    normalized = project_name.lower()
    normalized = re.sub(r"[\s_]+", "-", normalized)
    # Remove any characters that aren't alphanumeric or hyphens
    normalized = re.sub(r"[^a-z0-9-]", "", normalized)
    # Remove consecutive hyphens
    normalized = re.sub(r"-+", "-", normalized)
    # Remove leading/trailing hyphens
    normalized = normalized.strip("-")
    return f"ralph/{normalized}"


@dataclass
class PRDToJsonConverter:
    """Workflow for converting PRD markdown to JSON format.

    This workflow parses PRD markdown files (like those generated by PRDGenerator)
    and converts them to the JSON format used by Ralph's build loop.

    Attributes:
        prd_json: The converted PRD in JSON format.
        input_path: Path to the PRD markdown file.
        output_path: Path where prd.json will be saved.
    """

    prd_json: PRDJson = field(default_factory=PRDJson)
    input_path: str = "tasks/prd.md"
    output_path: str = "prd.json"

    def _parse_story_block(
        self, block: str, default_id: str, priority: int
    ) -> StoryData | None:
        """Parse a user story block from markdown.

        Args:
            block: Text block containing a user story.
            default_id: Default ID to use if none found.
            priority: Priority/order of the story.

        Returns:
            StoryData if parsing succeeded, None otherwise.
        """
        logger = get_logger()

        story_id = default_id
        title = ""
        description = ""
        criteria: list[str] = []

        lines = block.strip().split("\n")
        in_criteria = False

        for line in lines:
            line = line.strip()

            # Skip empty lines
            if not line:
                continue

            # Parse story header (### US-001: Title format)
            header_match = re.match(r"^###\s+(US-\d+):\s*(.+)$", line)
            if header_match:
                story_id = header_match.group(1)
                title = header_match.group(2).strip()
                in_criteria = False
                continue

            # Alternative header format (## US-001 - Title)
            alt_header_match = re.match(r"^##\s+(US-\d+)\s*[-â€“]\s*(.+)$", line)
            if alt_header_match:
                story_id = alt_header_match.group(1)
                title = alt_header_match.group(2).strip()
                in_criteria = False
                continue

            # Parse "As a" description
            if line.startswith("**As a**") or line.startswith("As a"):
                # Extract the "I want" part
                want_match = re.search(
                    r"[Ii]\s*want\s*(?:to\s+)?(.+?)(?:\s*[,.]?\s*(?:[Ss]o\s+that|$))",
                    line,
                )
                if want_match:
                    description = want_match.group(1).strip()
                    # Clean up any trailing punctuation or "so that" clause
                    description = re.sub(r"[,.]?\s*$", "", description)
                else:
                    # Fallback: take everything after "I want"
                    want_idx = line.lower().find("i want")
                    if want_idx != -1:
                        description = line[want_idx + 7:].strip()
                        description = re.sub(r"^to\s+", "", description)
                in_criteria = False
                continue

            # Detect acceptance criteria section
            if "acceptance criteria" in line.lower():
                in_criteria = True
                continue

            # Parse criteria items
            if line.startswith("-") and in_criteria:
                criterion = line[1:].strip()
                if criterion:
                    criteria.append(criterion)
                continue

            # Alternative: criteria without "Acceptance Criteria" header
            # (e.g., just bullet points after description)
            if line.startswith("-") and description and not in_criteria:
                criterion = line[1:].strip()
                if criterion:
                    criteria.append(criterion)
                    in_criteria = True  # Start collecting criteria

        # Validate we have minimum required fields
        if not title and not description:
            logger.debug(f"Skipping invalid story block: {block[:100]}")
            return None

        # Use title as description fallback
        if not description and title:
            description = title

        return StoryData(
            id=story_id,
            title=title,
            description=description,
            acceptance_criteria=criteria,
            priority=priority,
            passes=False,
            notes="",
        )

    def _parse_prd_markdown(self, content: str) -> PRDJson:
        """Parse PRD markdown content into PRDJson structure.

        Args:
            content: Raw PRD markdown content.

        Returns:
            Parsed PRDJson structure.
        """
        logger = get_logger()
        prd = PRDJson()

        lines = content.split("\n")

        # Extract project name from title
        for line in lines:
            line = line.strip()
            if line.startswith("# "):
                # Format: "# Product Requirements Document: Project Name"
                title_match = re.search(r":\s*(.+)$", line)
                if title_match:
                    prd.project = title_match.group(1).strip()
                else:
                    # Fallback: use the whole title without "# "
                    prd.project = line[2:].strip()
                break

        # Generate branch name from project
        if prd.project:
            prd.branch_name = _normalize_branch_name(prd.project)

        # Extract overview/description
        in_overview = False
        overview_lines: list[str] = []
        for line in lines:
            line_stripped = line.strip()
            if line_stripped.startswith("## Overview"):
                in_overview = True
                continue
            if in_overview:
                if line_stripped.startswith("## "):
                    # Next section started
                    break
                if line_stripped:
                    overview_lines.append(line_stripped)

        prd.description = " ".join(overview_lines)

        # Find and parse user stories section
        stories_start = -1
        stories_end = len(lines)

        for i, line in enumerate(lines):
            line_stripped = line.strip()
            if "User Stories" in line_stripped and line_stripped.startswith("## "):
                stories_start = i + 1
            elif stories_start != -1 and line_stripped.startswith("## "):
                stories_end = i
                break

        if stories_start == -1:
            logger.warning("No 'User Stories' section found in PRD")
            return prd

        # Extract story blocks
        stories_content = "\n".join(lines[stories_start:stories_end])

        # Split by story headers (### US-XXX)
        story_blocks = re.split(r"(?=###\s+US-\d+)", stories_content)

        # Also try alternative format (## US-XXX)
        if len(story_blocks) <= 1:
            story_blocks = re.split(r"(?=##\s+US-\d+)", stories_content)

        priority = 1
        for block in story_blocks:
            block = block.strip()
            if not block:
                continue

            story = self._parse_story_block(
                block,
                default_id=f"US-{priority:03d}",
                priority=priority,
            )
            if story:
                prd.user_stories.append(story)
                priority += 1

        logger.debug(f"Parsed {len(prd.user_stories)} stories from PRD")
        return prd

    def load_prd(self, path: str | None = None) -> str:
        """Load PRD markdown from file.

        Args:
            path: Optional override for input path.

        Returns:
            PRD markdown content.

        Raises:
            ValueError: If file is empty or doesn't exist.
        """
        input_path = path or self.input_path

        log_agent_action("PRDToJson", "Loading PRD", input_path)

        content = read_file(input_path)
        if not content:
            raise ValueError(f"PRD file is empty or doesn't exist: {input_path}")

        return content

    def parse(self, content: str | None = None, path: str | None = None) -> PRDJson:
        """Parse PRD markdown into JSON structure.

        Either content or path must be provided. If both are provided,
        content takes precedence.

        Args:
            content: PRD markdown content (optional).
            path: Path to PRD markdown file (optional).

        Returns:
            Parsed PRDJson structure.

        Raises:
            ValueError: If neither content nor path is provided.
        """
        if content is None:
            if path is None:
                path = self.input_path
            content = self.load_prd(path)

        log_agent_action("PRDToJson", "Parsing PRD markdown")

        self.prd_json = self._parse_prd_markdown(content)

        log_agent_action(
            "PRDToJson",
            "PRD parsed",
            f"{len(self.prd_json.user_stories)} stories",
        )

        return self.prd_json

    def save(self, path: str | None = None) -> Path:
        """Save prd.json to file.

        Args:
            path: Optional override for output path.

        Returns:
            Path where file was saved.

        Raises:
            ValueError: If no PRD has been parsed.
        """
        output_path = path or self.output_path

        if not self.prd_json.project:
            raise ValueError("No PRD parsed. Call parse() first.")

        json_content = self.prd_json.to_json()
        saved_path = write_file(output_path, json_content)

        log_agent_action("PRDToJson", "prd.json saved", str(saved_path))

        return saved_path

    def convert(
        self,
        input_path: str | None = None,
        output_path: str | None = None,
    ) -> PRDJson:
        """Convert PRD markdown file to prd.json.

        This is a convenience method that loads, parses, and saves in one call.

        Args:
            input_path: Path to PRD markdown file.
            output_path: Path for output prd.json file.

        Returns:
            Converted PRDJson structure.
        """
        log_agent_action("PRDToJson", "Starting conversion")

        # Load and parse
        content = self.load_prd(input_path)
        self.parse(content)

        # Save to output
        self.save(output_path)

        log_agent_action(
            "PRDToJson",
            "Conversion complete",
            f"{self.prd_json.project}: {len(self.prd_json.user_stories)} stories",
        )

        return self.prd_json

    def set_project_info(
        self,
        project_name: str | None = None,
        branch_name: str | None = None,
        description: str | None = None,
    ) -> None:
        """Manually set or override project information.

        Args:
            project_name: Project name.
            branch_name: Git branch name.
            description: Project description.
        """
        if project_name:
            self.prd_json.project = project_name
        if branch_name:
            self.prd_json.branch_name = branch_name
        elif project_name and not self.prd_json.branch_name:
            self.prd_json.branch_name = _normalize_branch_name(project_name)
        if description:
            self.prd_json.description = description

    def add_story(self, story: StoryData | dict[str, Any]) -> None:
        """Add a story to the PRD.

        Args:
            story: StoryData object or dictionary with story data.
        """
        if isinstance(story, dict):
            criteria = story.get("acceptanceCriteria") or story.get("acceptance_criteria") or []
            story = StoryData(
                id=story.get("id", f"US-{len(self.prd_json.user_stories) + 1:03d}"),
                title=story.get("title", ""),
                description=story.get("description", ""),
                acceptance_criteria=criteria,
                priority=story.get("priority", len(self.prd_json.user_stories) + 1),
                passes=False,  # Always set to false for new stories
                notes=story.get("notes", ""),
            )

        self.prd_json.user_stories.append(story)

    def get_story_count(self) -> int:
        """Get the number of stories in the PRD.

        Returns:
            Number of user stories.
        """
        return len(self.prd_json.user_stories)

    def validate(self) -> list[str]:
        """Validate the PRD structure.

        Returns:
            List of validation errors (empty if valid).
        """
        errors: list[str] = []

        if not self.prd_json.project:
            errors.append("Missing project name")

        if not self.prd_json.branch_name:
            errors.append("Missing branch name")

        if not self.prd_json.user_stories:
            errors.append("No user stories found")

        # Check for duplicate story IDs
        ids = [s.id for s in self.prd_json.user_stories]
        duplicates = [id_ for id_ in ids if ids.count(id_) > 1]
        if duplicates:
            errors.append(f"Duplicate story IDs: {', '.join(set(duplicates))}")

        # Check each story has required fields
        for story in self.prd_json.user_stories:
            if not story.id:
                errors.append(f"Story missing ID: {story.title or 'untitled'}")
            if not story.title and not story.description:
                errors.append(f"Story {story.id} missing title and description")
            if not story.acceptance_criteria:
                errors.append(f"Story {story.id} has no acceptance criteria")

        return errors
